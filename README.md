### 项目目标

该项目旨在创建一个“火烧云指数”预报服务。它通过从气象数据源（NOAA GFS 和 Copernicus CAMS）获取预报数据，经过一系列计算，最终生成一个量化的指数。项目通过两种方式提供服务：

1.  **API 端点**：提供查询特定地理坐标、特定事件（如今日日落）的火烧云指数。
2.  **静态 GeoJSON 文件**：为前端地图生成预先计算好的格点数据，展示大范围内的指数分布。

好的，我已经仔细阅读并理解了您提供的所有项目文件。

这是一个目标明确、结构清晰的后端项目，名为 `chromasky-backend`。其核心功能是**预测和可视化特定时间的“火烧云”天象指数**。

### 1. 核心流程

项目的整个生命周期可以分为三个主要阶段：

1.  **数据采集 (调度任务)**：由 `scheduler.py` 驱动，定期从 `NOAA` (GFS气象数据) 和 `Copernicus` (CAMS气溶胶数据) 下载原始的 GRIB 格式预报数据。
2.  **数据处理 (调度任务)**：下载完成后，立即触发 `processing_tasks.py`。这个模块是项目的计算核心，它会：
    *   根据天文算法 (`astronomy_service.py`) 计算出特定事件（如日落）在指定时间窗口内发生的地理区域（一个多边形）。
    *   筛选出落在这个区域内的 GFS 格点。
    *   **并行地**（使用多进程）为每个格点计算“火烧云指数”。
    *   将计算结果保存为 GeoJSON 文件，供前端直接使用。
    *   更新一个主清单文件 (`gfs_data_manifest.json`)，告知前端最新的数据路径。
3.  **数据服务与展示 (API与前端)**：
    *   一个 FastAPI Web 服务器 (`app/main.py`) 启动，并预加载最新的气象数据到内存中 (`DataFetcher` 单例)。
    *   服务器对外提供 API 接口，用于查询单点的详细指数和原始数据。
    *   同时，它也作为静态文件服务器，将 `frontend/index.html` 和处理好的 GeoJSON 文件提供给浏览器。
    *   前端页面 (`index.html`) 通过读取主清单文件，动态加载并用 MapLibre GL JS 在地图上渲染出火烧云指数的热力图。

### 2. 关键模块分析

*   **调度器 (`scheduler.py`, `app/tasks/`)**:
    *   这是整个自动化流程的入口。
    *   `gfs_tasks.py` 和 `cams_tasks.py` 职责明确，分别负责下载两种不同来源的数据。
    *   任务设计具有幂等性，会检查清单文件，如果数据已存在则跳过，避免重复下载。

*   **数据处理核心 (`app/tasks/processing_tasks.py`)**:
    *   **性能优化是亮点**：它没有对全球所有格点进行计算，而是先通过 `astronomy_service` 框定一个有效的计算区域，极大地减少了计算量。
    *   **并行计算**：通过 `concurrent.futures.ProcessPoolExecutor` 将繁重的计算任务分配给多个CPU核心，显著缩短了处理时间。
    *   **进程安全**：通过在每个工作进程中重新初始化 `DataFetcher` 来保证数据访问的独立性，这是一种有效且简单的并行策略。

*   **数据访问层 (`app/services/data_fetcher.py`)**:
    *   采用**单例模式**，确保在 FastAPI 应用生命周期内，所有数据只从磁盘加载一次，为 API 提供了快速响应能力。
    *   `force_reload` 参数的设计很巧妙，允许在不同上下文（API服务器 vs. 批处理任务）中灵活控制数据加载。
    *   它优雅地处理了 GRIB 文件中可能存在的 `stepType` 冲突问题。

*   **科学计算与算法 (`app/services/`)**:
    *   `astronomy_service.py`: 基于 `ephem` 库，不仅能计算单点的日出日落，还能计算出“等时线”，这是实现“Point-in-Area”优化的关键。
    *   `chromasky_calculator.py`: 封装了项目的核心商业逻辑——“火烧云指数”的评分函数。这些函数 (`score_local_clouds`, `score_light_path` 等) 将气象数据转化为最终的用户可见分数。
    *   `grib_downloader.py`: 封装了与 NOAA GFS 数据源的交互细节，使上层任务逻辑更清晰。

*   **API 和前端 (`app/api/`, `frontend/`)**:
    *   API 设计遵循 RESTful 风格，提供了单点查询、数据调试等多种接口。
    *   前端 `index.html` 与后端解耦良好，它不关心数据是如何计算的，只通过一个主清单文件 (`gfs_data_manifest.json`) 来发现和加载最新的 GeoJSON 数据，实现了动态更新。

*   **配置 (`app/core/`)**:
    *   配置分离做得很好，`download_config.py` 集中管理了所有关键参数，如计算区域、时间、数据源变量等，便于调整和维护。

*   **调试工具 (`debug_grib.py`)**:
    *   提供了一个实用的命令行工具来探查复杂的 GRIB 文件内容，这在开发和调试阶段非常有价值。

总结来说，这是一个设计精良、功能完备的数据驱动型应用。从数据采集、处理、计算到最终的可视化，整个流程自动化且高效。代码结构清晰，职责分离明确。

我已完全理解该项目的架构和实现细节。

好的。


### ChromaSky™ 火烧云指数计算核心算法

本项目的核心是 `ChromaSky™ 指数`，这是一个综合评分（0-10分），用于量化在特定地点和时间观赏到壮观日出/日落（即“火烧云”）的潜力。该指数的计算基于一个四因子乘法模型，任何一个因子的缺失都会显著降低总分。

#### 最终指数公式

```
指数 = 因子A × 因子B × 因子C × 因子D × 10
```

其中，每个因子的取值范围均为 `0.0` 到 `1.0`。

---

#### 因子A: 本地云况 (The Canvas)

**目的**: 评估观测点上空是否存在适合被霞光染色的“画布”（即中高云）。

**公式**:
```python
# hcc = 高云量 (%), mcc = 中云量 (%)
canvas_cloud_cover = hcc + mcc

if canvas_cloud_cover < 20:
    factor_A = 0.1  # 云量太少，得分极低
else:
    factor_A = 1.0  # 云量充足，得满分
```
*   **数据源**: `hcc` (高云量), `mcc` (中云量)
*   **解读**: 没有中高云作为画布，即使光线再好也无法形成壮观的火烧云。

---

#### 因子B: 光照路径 (The Window)

**目的**: 评估从太阳到观测点上空云层的光路是否干净，即日出/日落方向是否存在清晰的“晴空窗口”。这是最重要的影响因子。

**公式**:
```python
# avg_tcc_along_path = 光路上的平均总云量 (%)
clarity = (100 - avg_tcc_along_path) / 100

factor_B = clarity ** 2
```
*   **数据源**: `tcc` (总云量)
*   **解读**:
    *   需要沿着日出/日落的方位角，从观测点向外回溯约 400-500 公里，采样多个点的总云量并计算其平均值 `avg_tcc_along_path`。
    *   使用**平方** (`** 2`) 是为了加大对路径中有云的惩罚。即使路径上只有 30% 的云量，`clarity` 为 `0.7`，最终得分 `factor_B` 也会降至 `0.49`，对总分产生巨大影响。

---

#### 因子C: 空气质量 (The Filter)

**目的**: 评估光路上的大气通透度。干净的空气能有效散射短波光（蓝光），让长波光（红光）通过，形成鲜艳的色彩。浑浊的空气则会直接吸收和散射所有光线，使天空变得灰暗。

**公式 (基于AOD估算)**:
```python
# aod = 气溶胶光学厚度 (Aerosol Optical Depth)
if aod < 0.2:
    factor_C = 1.0  # 空气极佳
elif aod > 0.8:
    factor_C = 0.0  # 空气极差
else:
    # 在 0.2 到 0.8 之间线性下降
    factor_C = 1.0 - ((aod - 0.2) / 0.6)
```
*   **数据源**:
    *   **最佳**: ECMWF CAMS 或 GEFS-Aerosols 模型的 AOD 数据。
    *   **当前项目 (V1)**: 暂时使用一个基于季节的**估算值**，例如夏季 `0.4`，冬季 `0.2`。

---

#### 因子D: 云层高度 (The Scale)

**目的**: 评估云层的高度。越高的云能被阳光照射的时间越长，形成的火烧云规模也可能更宏大。

**公式**:
```python
# cloud_base_meters = 云底高度 (米)
if cloud_base_meters is None or isnan(cloud_base_meters):
    factor_D = 0.0 # 没有云
elif cloud_base_meters > 6000:
    factor_D = 1.0 # 高云，最佳
elif cloud_base_meters > 2500:
    factor_D = 0.7 # 中云，良好
else:
    factor_D = 0.3 # 低云，较差
```
*   **数据源**: `gh` (位势高度) @ `cloudCeiling` (云幂) 层级，直接获取最低云层的底部高度。

---

### **实现流程概览**

1.  **数据准备**: 后台定时任务 (`scheduler.py`) 每日两次从 GFS 下载未来四个关键事件（今明两天日出日落）的 `tcc`, `hcc`, `mcc`, `lcc`, `gh` 等数据，并生成 `manifest.json`。
2.  **API 请求**: 用户通过 API 请求特定地点 (`lat`, `lon`) 和事件 (`event`) 的指数。
3.  **数据提取**: `data_fetcher.py` 从缓存中提取该事件、该地点的原始气象数据。
4.  **光路分析**: `chromasky_calculator.py` 计算太阳方位角，并沿着该路径回溯采样，计算出 `avg_tcc_along_path`。
5.  **指数计算**: `chromasky_calculator.py` 调用上述四个评分函数，计算出各因子得分和最终总分。
6.  **返回结果**: API 将总分和各因子分项得分一并返回给前端。